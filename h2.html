<!DOCTYPE html>
<html>
<head>
<title>Conteudo da N2</title>
<link rel="stylesheet" href=
"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
<link rel="stylesheet" href="./Estilos/principal.css">
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://code.iconify.design/iconify-icon/1.0.7/iconify-icon.min.js"></script>

</head>
<body>


<div class="logomarca">
	<img src="Imagens/Logomarca.png" alt="logomarcaa">
</div>		


	<nav class="menu">
		
		<ul>
	
			<li>
				<a href="index.html"><h3>Página Inicial</h3></a>
			</li>
			<li>
				<a href="#"><h3>Blogs Sobre Tecnologia</h3></a>
					<ul>
            <li><a href="artigo_firewall.html"><h4>O que é um Firewall?</h4></a></li>
						<li><a href="artigo_linux.html"><h4>Sistemas Linux</h4></a></li>
						<li><a href="artigo_sistemasope.html"><h4>Sistemas Operacionais</h4></a></li>
					</ul>
			</li>
			<li>
				<a href="#"><h3>Atividades da Faculdade</h3></a>
					<ul>
						<li><a href="h1.html"><h4>Conteudos da N1 de complexidade</h4></a></li>
                        <li><a href="h2.html"><h4>Conteudos da N2 de complexidade</h4></a></li>
					</ul>
			</li>
			<li>
				<a href="#"><h3>Entre em Contato Comigo</h3></a>
			</li>
		</ul>
	</nav>
		</div>

	</nav>


    <nav class="titulo_h1">
        <h1 id="titulo_h1">Conteudos da N2 de Complexidade de Algoritmos</h1>
        



    <ul>
        <li><a href="#guloso">Algoritmos Gulosos</a></li>
        <li><a href="#divisao">Algoritmos de Divisão e Conquista</a></li>
        <li><a href="#complexidade">Complexidade de Problemas</a></li>
    </ul>
    
    
    
    <section>
        <nav class="conteudo_n2">
    <h2>Algoritmos Gulosos</h2>
    <p>Os algoritmos gulosos, também conhecidos como algoritmos vorazes, são uma classe de algoritmos que resolvem problemas tomando decisões localmente ótimas em cada etapa, com a esperança de que essas decisões levem a uma solução globalmente ótima.
        A complexidade dos algoritmos gulosos pode variar dependendo do problema específico que está sendo resolvido. Em alguns casos, os algoritmos gulosos podem ter uma complexidade linear ou quase linear, o que significa que o tempo de execução aumenta proporcionalmente ao tamanho da entrada.
        No entanto, é importante ressaltar que nem todos os problemas podem ser resolvidos com algoritmos gulosos, e nem todos os algoritmos gulosos são eficientes em termos de complexidade. Alguns problemas podem exigir estratégias mais complexas, como programação dinâmica ou busca em profundidade, para obter uma solução ótima.
        Portanto, ao analisar a complexidade de um algoritmo guloso, é necessário levar em consideração o problema específico que está sendo resolvido e a estratégia adotada pelo algoritmo. Em geral, a complexidade dos algoritmos gulosos pode ser determinada pela análise do tempo de execução de cada etapa do algoritmo e pela análise do número de iterações necessárias para chegar à solução final.
        
        
        
        Jamais se arrepende de uma decisão, as escolhas realizadas são definitivas;
        Não leva em consideração as consequências de suas decisões;
        Podem fazer cálculos repetitivos;
        Nem sempre produz a melhor solução (depende da quantidade de informação fornecida);
        Quanto mais informações, maior a chance de produzir uma solução melhor.
        Algoritmos Gulosos vs Programação Dinâmica
        
        Em um algoritmo de programação dinâmica a escolha pode depender da solução dos subproblemas, enquanto um algoritmo guloso vai tentar escolher a melhor solução naquele momento.
        A solução dos problemas na programação dinâmica parte de baixo para cima, enquanto um algoritmo guloso vai de cima para baixo, ou seja, na programação dinâmica, as soluções para todos os subproblemas são calculadas partindo dos menores subproblemas para os maiores.
        Os resultados dos subproblemas na programação dinâmica são salvos, facilitando a prova de correção.
        
        Pontos a favor
        
        -Simples e de fácil implementação;
        -Algoritmos de rápida execução;
        -Podem fornecer a melhor solução (estado ideal).
        
        Pontos Contra
        
        -Dependentes de informações;
        -Correm o risco de entrarem em loops infinitos;
        -Situacionais, só resolvem tipos específicos de problemas;
        -Decisões tomadas são irrevogáveis;</p>

    

        <h2>Algoritmos de Divisão e Conquista</h2>
    <p>Os algoritmos de divisão e conquista são uma classe de algoritmos que dividem um problema em subproblemas menores, resolvem cada subproblema de forma independente e depois combinam as soluções dos subproblemas para obter a solução final do problema.
        A complexidade dos algoritmos de divisão e conquista pode variar dependendo do problema específico que está sendo resolvido. Em geral, esses algoritmos possuem uma complexidade de tempo de O(n log n), onde n é o tamanho da entrada. No entanto, em alguns casos, a complexidade pode ser pior, como O(n^2) ou O(2^n), dependendo da forma como os subproblemas são resolvidos e combinados.
        A análise de complexidade dos algoritmos de divisão e conquista geralmente envolve a análise do tempo de execução de cada etapa do algoritmo. No caso do conhecido algoritmo de ordenação "merge sort", a complexidade é O(n log n), onde n é o número de elementos a serem ordenados. Isso ocorre porque o algoritmo divide repetidamente a lista de elementos pela metade, realiza a ordenação de cada metade separadamente e, em seguida, combina as metades ordenadas em uma única lista.</p>
    
    
    
    
        <h2>Complexidade de Problemas</h2>
    <p>A complexidade de um problema em relação a algoritmos refere-se à quantidade de recursos necessários para resolver o problema usando um algoritmo específico. Geralmente, a complexidade de um problema é expressa em termos de tempo de execução (complexidade temporal) e/ou uso de espaço (complexidade espacial).
        A complexidade temporal é uma medida do tempo necessário para executar um algoritmo em relação ao tamanho da entrada. Ela é geralmente expressa usando a notação O (Big O), que descreve o crescimento assintótico do tempo de execução em relação ao tamanho da entrada. Por exemplo, se um algoritmo tem complexidade O (n^2), isso significa que o tempo de execução do algoritmo cresce quadraticamente com o tamanho da entrada.
        A complexidade espacial é uma medida da quantidade de espaço de memória necessário para executar um algoritmo em relação ao tamanho da entrada. Ela também é expressa usando a notação O (Big O), que descreve o crescimento assintótico do uso de espaço em relação ao tamanho da entrada. Por exemplo, se um algoritmo tem complexidade O (n), isso significa que o uso de espaço do algoritmo cresce linearmente com o tamanho da entrada.
        A complexidade de um problema pode variar dependendo do algoritmo escolhido para resolvê-lo. Alguns problemas podem ser resolvidos de forma eficiente com algoritmos de complexidade polinomial, enquanto outros podem ser intratáveis e requerer algoritmos de complexidade exponencial.
        A análise de complexidade de problemas em relação a algoritmos é importante para avaliar a viabilidade e eficiência de diferentes abordagens para resolver um problema. Ela ajuda a identificar a melhor estratégia de resolução, considerando as restrições de tempo e espaço.</p>
     
    </nav>
</section>




<footer class="page-footer">
    <div class="container">
      <div class="row">
        <div class="col l6 s12">
          <p class="grey-text text-lighten-4"> Gostaria de entrar em contato? preencha o formulário clicando abaixo.</p>

          <a class="waves-effect waves-light btn green" href="Contato.html"> Clique aqui</a>
        </div>
        <div class="col l4 offset-l2 s12">
          <h5 class="white-text">Siga minhas redes sociais</h5>
          <center>
          <ul>
           <h6 class="redes_sociais">caua.ti@gmail.com<h6>
            <a href="https://www.linkedin.com/in/cau%C3%A3-pablo-ti/" class="fa fa-linkedin"></a>		
            <a href="https://github.com/Caua-Pablo?tab=repositories" class="fa fa-github"></a>
            <a class="gmaail" href="mailto:cauapablo.ti@gmail.com"><iconify-icon icon="logos:google-gmail"></iconify-icon>
          </ul>
          </center>
        </div>
      </div>
    </div>



</section>

	

</body>
</html>


























